#+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: reveal_title_slide:"<h1>%t</h1><h2>%a</h2><h4>Queensland&nbsp;Functional&nbsp;Programming&nbsp;Lab</h4><h3>%e</h3>"
#+OPTIONS: num:nil
#+OPTIONS: toc:nil

#+TITLE: Property Base Your State Machine
#+AUTHOR: Sean Chalmers, Jack Kelly
#+EMAIL:

* Programs are weird
  Complex, Dependent, Interactive

* Testing weird is hard
  - manual testing? [cries in Quality Assurance]
  - which processes/use cases do you test?
  - testing for failure?

* Do what we can
  - unit test functions
  - maybe test functions that use other functions
  - test 'expected' use
  - subcontract end users to suggest regression tests

* Cost : Benefit
  - multi-step testing can be arduous and brittle
    - input and process are static
    - coverage
    - new feature? have fun!
 
* Property-based testing
  - fob off the boring bits
  - frustratingly thorough
  - staggeringly useful

** Squeeeeeze
  Use classification to understand your test-case distribution
  - John Hughes: Building on developer intuitions
    - https://www.youtube.com/watch?v=NcJOiQlzlXQ

* Property-based state machine testing
  Property-based testing, lifted to the level of *application behaviour*.

** Generate useful workflows
   list of actions is randomly generated, but guided by your requirements

** Generated structured inputs
   create useful randomised inputs for actions

** Shrinking (OMG!)
   you thought shrinking inputs was cool...

** Useful feedback
   - test failure provides list on actions and their respective inputs
   - the random seed is provided so you can reproduce *that* failure

* How?! Tell meeeee!

** The basics
   - drawn from Hedgehog package
   - concepts are /similar/ across different packages/languages

** Command
   The workhorse
   - pre/post conditions
   - input generation
   - action execution

** Model
   Your expectations regarding the 'state' of the world.

* For example
  [[./images/mach.png]]

* There be dangers
  Run the risk of writing a terrible duplicate of what you're testing.
  - comparison of:
    - state machine with **states** highlighted
    - state machine with **transitions** highlighted

* Ssssymbolism

* Machines that grow
  - New feature ~ new instruction(s)
  - Leave it to the framework to weave in the new instruction

* Bonus awesome

* Some cool examples of applications of state-machine testing
  - direct ((our)coffee machine/turnstile)
  - external (wordpress, levelDB)

* important notes:
  - Jack: "The thing that made the name click for me: **each command is a
    transition**. I carried around a model of 'you sketch out a state machine
    like you do in automata theory class' for far too long"
