# Level 01 - Simple Commands

The first thing we're going to test is drink selection. The machine
can be switched between coffee, hot chocolate and tea, and we're going
to define commands for each operation. We'll then build the commands
up into a state machine test and walk through how it's wired into a
larger test suite.

The first thing we'll need is a model of the coffee machine. The model
for a test does not have to replicate the entire system perfectly; we
start small, capturing the things we understand as we build our
commands and observe their interactions. Open up
`level01/CoffeeMachineTests.hs`, where you'll find the following model
defined for you:

```haskell
data DrinkType = Coffee | HotChocolate | Tea
newtype Model (v :: Type -> Type) = Model DrinkType
```

Note that `Model` has a mysterious type parameter `v`, and to give the
_kind signature_ `Type -> Type` to `v` we've had turn on `{-# LANGUAGE
KindSignatures #-}` as GHC will not infer the correct kind
otherwise. You can get away with cargo-culting this for the moment,
but if you're the sort of person who needs to dig through the details,
check out the asides below:

<details>
  <summary>Kind Signatures? Wha?</summary>

  A _kind_ is the "type" of a type. The kind `Type` is the kind of
  types that can have values. Consider `Maybe` - its type argument
  must be a type that can have values, and it can have values once
  it's fully applied (like in `Maybe Int`), so its kind is `Type ->
  Type`. (You might have seen this written as `* -> *` in the past;
  `*` is now an alias for `Type`.)

  This means that our `Model` type takes one type argument of kind
  `Type -> Type`; something `Functor`-shaped.
</details>

<details>
  <summary>What's the type parameter used for? I need to know!</summary>

  Hedgehog generates complete command sequences before it runs any
  commands, and not every command can be run at any time. Example: if
  your web service has commands that need administrator powers, you
  need to register an admin before you try running those commands.

  This means that generators need to see the current model state. At
  the same time, you can't know what the exact values in the state
  are, because the test hasn't run yet!

  Hedgehog works around this with two types:
  [`Symbolic`](https://hackage.haskell.org/package/hedgehog-0.6.1/docs/Hedgehog.html#t:Symbolic)
  and
  [`Concrete`](https://hackage.haskell.org/package/hedgehog-0.6.1/docs/Hedgehog.html#t:Concrete)
  . In the generation phase of the test, your model is a `Model
  Symbolic`, but once it starts executing it becomes a `Model
  Concrete` and you can pull out real values from the model.
</details>

*****

Now that we have our model, we need to build some commands to act on
it. The core type you need to understand is
[`Command`](https://hackage.haskell.org/package/hedgehog-0.6.1/docs/Hedgehog.html#t:Command),
reproduced here with some type variables renamed:

```haskell
data Command g m (state :: (* -> *) -> *) =
  forall input output.
  (HTraversable input, Show (input Symbolic), Typeable output) =>
  Command {
    -- | A generator which provides random arguments for a command. If the
    --   command cannot be executed in the current state, it should return
    --   'Nothing'.
    --
      commandGen ::
        state Symbolic -> Maybe (g (input Symbolic))

    -- | Executes a command using the arguments generated by 'commandGen'.
    --
    , commandExecute ::
        input Concrete -> m output

    -- | A set of callbacks which provide optional command configuration such
    --   as pre-condtions, post-conditions and state updates.
    --
    , commandCallbacks ::
        [Callback input output state]
    }
```



 is walk through the `test-suite` component to familiarise ourselves
with the libraries we.

We're using [`tasty`](https://hackage.haskell.org/package/tasty) to
define the test suite, and
[`tasty-hedgehog`](https://hackage.haskell.org/package/tasty-hedgehog)
to connect our tests to the Tasty `TestTree`. We've done this so
you'll know how to integrate hedgehog tests into your existing test
suite.

`level01/Main.hs` is the entry point for the test suite, and will stay
largely the same across levels. It defines a single `TestTree` which
imports the actual `stateMachineTests :: TestTree` from
`level01/CoffeeMachineTests.hs`.

 test is drink selection
